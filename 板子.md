# 一、树相关

## 1.1 二叉树前序遍历

根-左子树-右子树

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func preorderTraversal(root *TreeNode) (vals []int) {
    var preorder func(*TreeNode)
    preorder = func(node *TreeNode){
        if node == nil{
            return
        }
        vals = append(vals, node.Val)
        preorder(node.Left)
        preorder(node.Right)
    }
    preorder(root)
    return
}

func preorderTraversal(root *TreeNode) (vals []int) {
    stack := []*TreeNode{}
    node := root
    for node != nil || len(stack) > 0 {
        for node != nil {
            vals = append(vals, node.Val)
            stack = append(stack, node)
            node = node.Left
        }
        node = stack[len(stack)-1].Right
        stack = stack[:len(stack)-1]
    }
    return
}
```

## 1.2 二叉树中序遍历

左子树-根-右子树

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func inorderTraversal(root *TreeNode) (res []int) {
    var inorder func(node *TreeNode)
	inorder = func(node *TreeNode) {
		if node == nil {
			return
		}
		inorder(node.Left)
		res = append(res, node.Val)
		inorder(node.Right)
	}
	inorder(root)
	return
}

func inorderTraversal(root *TreeNode) (res []int) {
	stack := []*TreeNode{}
	for root != nil || len(stack) > 0 {
		for root != nil {
			stack = append(stack, root)
			root = root.Left
		}
		root = stack[len(stack)-1]
		stack = stack[:len(stack)-1]
		res = append(res, root.Val)
		root = root.Right
	}
	return
}

```

## 1.3 二叉树后序遍历

左子树—右子树—根节点

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func postorderTraversal(root *TreeNode) (res []int) {
    var postorder func(node *TreeNode)
    postorder = func(node *TreeNode){
        if node == nil{
            return
        }
        postorder(node.Left)
        postorder(node.Right)
        res = append(res, node.Val)
    }
    postorder(root)
    return
}

func postorderTraversal(root *TreeNode) (res []int){
    stack := []*TreeNode{}
    var prev *TreeNode
    for root != nil || len(stack) > 0{
        for root!=nil{
            stack = append(stack, root)
            root = root.Left
        }
        root = stack[len(stack) - 1]
        stack = stack[:len(stack) - 1]
        if root.Right == nil || root.Right == prev{
            res = append(res, root.Val)
            prev = root
            root = nil
        } else{
            stack = append(stack, root)
            root = root.Right
        }
    }
    return
}
```

## 1.4 二叉树层序遍历

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func levelOrder(root *TreeNode) [][]int {
    ret := [][]int{}
    if root == nil{
        return ret
    }
    queue := []*TreeNode{root}
    for i:=0;len(queue)>0;i++{
        ret = append(ret, []int{})
        p := []*TreeNode{}
        for j:=0;j<len(queue);j++{
            node := queue[j]
            ret[i] = append(ret[i], node.Val)
            if (node.Left != nil){
                p = append(p, node.Left)
            }
            if (node.Right != nil){
                p = append(p, node.Right)
            }
        }
        queue = p
    }
    return ret
}
```

# 二、字符串相关

## 2.1 Go字符串

### 不可变性
定义: 在Go中创建的每一个字符串都是不可变的。这意味着不能直接修改字符串中的字符。这种设计可以为字符串操作带来一些性能优势，尤其是在字符串复制和传递时。

例子:
```go
str := "GoLang"
// str[0] = 'g'  // 这会报错
newStr := "g" + str[1:]
fmt.Println(newStr)  // 输出: golang, 通过创建新的字符串来"修改"原字符串
```

### Go字符串的内部表达
定义: Go字符串背后是一个字节数组，这也意味着Go能够存储任何数据，不仅仅是UTF-8文本。

例子:
```go
// 字符串和其对应的字节
str := "Hello"
for i := 0; i < len(str); i++ {
    fmt.Printf("%x ", str[i])  // 输出每个字符的十六进制表示
}
// 输出: 48 65 6c 6c 6f
```

### byte和rune的简介
定义:

byte是uint8的别名，通常用于处理ASCII字符。
rune是int32的别名，用于处理一个UTF-8字符或Unicode码点。
例子:
```go
// byte和ASCII字符
byteValue := byte('A')
fmt.Println(byteValue)  // 输出: 65

// rune和UTF-8字符
runeValue := rune('你')
fmt.Printf("%#U \n", runeValue)  // 输出: U+4F60
```

## 2.2 字符串常用方法

### 字符串连接

```go
// 字符串连接
str1 := "Hello"
str2 := "World"
result := str1 + ", " + str2
fmt.Println(result)  // 输出: Hello, World
```

### 字符串切片
```go
// 字符串切片
str := "GoLang"
subStr := str[2:4]
fmt.Println(subStr)  // 输出: La
```

### 字符串查找

使用strings包中的函数，如Contains、Index等，可以轻松查找子串或字符。

```go
import "strings"

str := "Hello, Go!"
found := strings.Contains(str, "Go")
fmt.Println(found)  // 输出: true

position := strings.Index(str, "Go")
fmt.Println(position)  // 输出: 7
```

### 字符串比较

Go提供了一种原生的方式来比较两个字符串是否相等。此外，strings库中的Compare函数可以用来确定两个字符串在字典序上的先后关系。

```go
str1 := "apple"
str2 := "banana"

// 使用==比较字符串
isEqual := str1 == str2
fmt.Println(isEqual)  // 输出: false

// 使用strings.Compare比较字符串
compResult := strings.Compare(str1, str2)
fmt.Println(compResult)  // 输出: -1, 表示str1在str2之前
```

### 字符串的替换

使用strings包中的Replace和ReplaceAll函数，您可以在字符串中替换子串。

```go
source := "go is good, go is great"
replaced := strings.ReplaceAll(source, "go", "Go")
fmt.Println(replaced)  // 输出: Go is good, Go is great
```
### 字符串的大小写转换

strings库为大小写转换提供了ToUpper和ToLower函数。

```go
str := "GoLang"
lowercase := strings.ToLower(str)
uppercase := strings.ToUpper(str)
fmt.Println(lowercase)  // 输出: golang
fmt.Println(uppercase)  // 输出: GOLANG
```

### 使用正则表达式处理字符串

regexp库提供了一系列函数来使用正则表达式进行字符串的查询、匹配、替换和切分。

```go
import "regexp"

str := "My email is example@example.com"
re := regexp.MustCompile(`[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,4}`)
email := re.FindString(str)
fmt.Println(email)  // 输出: example@example.com
```

### 字符串的加密与哈希

Go的crypto包提供了多种加密算法，您可以使用它们来加密字符串或计算字符串的哈希。

```go
import (
    "crypto/md5"
    "fmt"
    "io"
)

str := "secret data"
hasher := md5.New()
io.WriteString(hasher, str)
fmt.Printf("%x\n", hasher.Sum(nil))  // 输出: md5哈希值
```

### 字符串拆分

使用strings.Split函数，可以按指定的分隔符将字符串拆分为子串的切片。

```go
str := "apple,banana,cherry"
items := strings.Split(str, ",")
fmt.Println(items)  // 输出: [apple banana cherry]
```

### 字符串合并
strings.Join函数能够将一个字符串切片合并为一个单独的字符串。

```go
items := []string{"apple", "banana", "cherry"}
str := strings.Join(items, ", ")
fmt.Println(str)  // 输出: apple, banana, cherry
```

### 获取字符串中的字符
可以通过索引访问字符串中的每个字符，但返回的是字符的byte值。

```go
str := "Go"
byteValue := str[1]
fmt.Println(byteValue)  // 输出: 111 (ASCII码的'o')
```

### 字符串中字符的遍历
使用for range循环可以迭代字符串中的每个字符。

```go
str := "Go"
for index, char := range str {
    fmt.Printf("At index %d, char: %c\n", index, char)
}
```

### 修剪字符串
strings.TrimSpace函数可以去除字符串首尾的空格。

```go
str := "   Go Lang   "
trimmed := strings.TrimSpace(str)
fmt.Println(trimmed)  // 输出: Go Lang
```

### 填充字符串
使用fmt包，您可以使用特定的格式修饰符来填充或对齐字符串。

```go
str := "Go"
padded := fmt.Sprintf("%-10s", str)
fmt.Println(padded)  // 输出: Go
```

### 字符串的统计
strings.Count函数可以帮助统计一个子串在字符串中出现的次数。

```go
str := "Go is easy to learn. Go is powerful."
count := strings.Count(str, "Go")
fmt.Println(count)  // 输出: 2
```

## 2.3 使用标准库处理字符串

### strings库概览
strings库提供了一系列强大的函数，用于字符串的查询、替换、转换和切分等操作。

```go
import "strings"

str := "go is awesome"
title := strings.Title(str)
fmt.Println(title)  // 输出: Go Is Awesome
```

### 其他有用的字符串库

strconv库：用于字符串与其他基本数据类型之间的转换。

```go
import "strconv"

number := 12345
strNum := strconv.Itoa(number)
fmt.Println(strNum)  // 输出: "12345"
```

unicode库：用于检查字符属性，如是否为数字、字母等。

```go
import "unicode"

ch := 'A'
isLetter := unicode.IsLetter(ch)
fmt.Println(isLetter)  // 输出: true
```

## 2.4 Go字符串类型转换

### 字符串与整数

整数转字符串

使用strconv.Itoa函数可以将整数转换为字符串。

```go
num := 123
str := strconv.Itoa(num)
fmt.Println(str)  // 输出: "123"
```

字符串转整数

strconv.Atoi函数可以将字符串转换为整数。

```go
str := "456"
num, err := strconv.Atoi(str)
if err != nil {
    fmt.Println(err)
} else {
    fmt.Println(num)  // 输出: 456
}
```

### 字符串与浮点数

浮点数转字符串

使用strconv.FormatFloat函数，可以将浮点数转换为字符串。

```go
f := 3.14
str := strconv.FormatFloat(f, 'f', 2, 64)
fmt.Println(str)  // 输出: "3.14"
```

字符串转浮点数

strconv.ParseFloat函数可以将字符串转换为浮点数。

```go
str := "5.67"
f, err := strconv.ParseFloat(str, 64)
if err != nil {
    fmt.Println(err)
} else {
    fmt.Println(f)  // 输出: 5.67
}
```

### 字符串与字节切片

字符串转字节切片

使用类型转换可以将字符串转换为字节切片。

```go
str := "Go"
bytes := []byte(str)
fmt.Println(bytes)  // 输出: [71 111]
```

字节切片转字符串

使用类型转换，可以将字节切片转换为字符串。

```go
bytes := []byte{72, 101, 108, 108, 111}
str := string(bytes)
fmt.Println(str)  // 输出: "Hello"
```


# 三、回溯

## 3.1 递归实现二进制枚举（子集枚举）

从 n 个当中选 k 个的所有方案对应的枚举是组合型枚举。

先回忆一下如何用递归实现二进制枚举（子集枚举），假设我们需要找到一个长度为 n 的序列 a 的所有子序列，代码框架是这样的：

```go
func function(n int, k int) (ans [][]int){
    temp := []int{}
	var dfs func(int)
	dfs = func(cur int) {
		// 剪枝
        //
		// 记录合法的答案
		if ... {
			return
		}
		// 考虑选择当前位置
		temp = append(temp, cur)
		dfs(cur + 1)
		temp = temp[:len(temp)-1]
		// 考虑不选择当前位置
		dfs(cur + 1)
	}
	dfs(1)
	return
}
```




